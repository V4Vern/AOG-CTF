# Format Leak

Difficulty Level: Easy
 
Format Strings (or printf) weirdly enough is vulnerable if not done properly.
 
Find a way to print the flag through [format strings](https://www.exploit-db.com/docs/english/28476-linux-format-string-exploitation.pdf)
 
FYI the attached flag.txt is just for testing the binary, it is **NOT** the flag
 
Connect via `nc challenge.ctf-fun.xyz 14014`

PS: Challenges in this category require a linux environment read [here](https://docs.google.com/document/d/13RjL_RWibA9xYOKvSCXpTGG0D2ZYa3kDzprGNa8ypeA/edit?usp=sharing) for a guide to installing a linux VM

### Hints

- You can leak stack values in hex using %x

## Deployment

```bash
cd service
sudo ./formatleak.sh &
```

## Solution
Looking at the source code we see that flag is placed after buffer. 
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define FLAGSIZE 64

void vulnerable() {
	char buffer[128] = {0x00};
	char flag[FLAGSIZE] = {0x00};

	// Reading flag file
	FILE *f = fopen("flag.txt","r");
	
	if (f == NULL) {
		printf("Flag File is Missing.\n");
		exit(0);
	}

	fgets(flag,FLAGSIZE,f);

	// start of vulnerability
	printf("Printf is cool and all but what happens when you just send a format string such as %%x?\n");
	printf("Look out for the hex of 19C4\n");

	fgets(buffer, sizeof(buffer), stdin);
	printf(buffer); // this is the vulnerablility
}	

int main(){
	setvbuf(stdout, NULL, _IONBF, 0);

	vulnerable();
}
```
The vulnerability lies with `printf(buffer)`. Normally if we do `print("A normal sentence")` nothing bad will happen but what happens when we send a format string instead `print("%x")`. This will print out the hex value of the stack. The more %x you add the more values of the stack it will print. 

If we look at the stack when it is about to call `printf(buffer)` you see that flag is placed nearer to the top of the stack thus when you try to leak it, it gets leaked before buffer.

| stack value (Direction of Stack grows upwards)|
| --------------------------------------------- |
| location of buffer (0xffffd12c) |
| random values |
| random values |
| char Flag[64] |
| char Buffer[128] | 

Now we just need to leak as much as possible to see the flag. If we can find the hex of 19C4 we will know where the flag is located then decode the hex with [cyberchef](https://gchq.github.io/CyberChef/#recipe=Swap_endianness('Hex',4,true)From_Hex('Auto')&input=MzQ0MzM5MzE2MTMzNmM3YjY3NmU2OTZiMzQzMTY2NWY3NzVmN2E2NzVmNjg3NDMxN2Q3NTMwNzkwMDAwMA)

![image1](../screenshots/formatleak/image1.png?raw=true "image 1")

![image1](../screenshots/formatleak/image2.png?raw=true "image 2")

### Flag
19C4{l3aking_f14gz_w1th_y0u}